<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Kawaii Play TV</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
<meta name="theme-color" content="#1A1A2E">
<style>
/* --- 2. CSS Completamente Revisado y Optimizado para TV --- */
:root {
  --primary-bg: #1A1A2E; 
  --secondary-bg: #272842; 
  --card-bg: #323354;
  --text-primary: #E8EAF6; 
  --text-secondary: #9FA8DA; 
  --accent-pink: #FF69B4; 
  --accent-yellow: #FFD700; 
  --border-color: #4A4A6E;
  --watched-color: #4CAF50;
  --focus-color: var(--accent-yellow); 
  --focus-scale: 1.12; 
  --menu-width: 320px; /* Ancho del men√∫ fijo */
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: var(--primary-bg);
  color: var(--text-primary);
  /* Permitimos el scroll solo en el contenido principal */
  overflow: hidden; 
  scroll-behavior: smooth; 
}

/* --- Accesibilidad y Foco --- */
*:not(button, a, input, [tabindex="0"]):focus {
    outline: none !important;
}


/* --- Header & Navigation (Oculto en modo men√∫ permanente) --- */
header {
  display: none; /* Ocultamos el header y hamburguesa ya que el men√∫ es permanente */
}

/* --- MEN√ö PERMANENTE (Estilo TV) --- */
#side-menu {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: var(--menu-width); 
    background: var(--secondary-bg);
    z-index: 1001;
    padding-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    border-right: 3px solid var(--accent-pink);
    box-shadow: 5px 0 15px rgba(0,0,0,0.5);
    /* Siempre abierto y visible */
    transform: translateX(0) !important; 
    transition: none !important;
}

.search-container {
    padding: 0 20px 20px;
}

#side-menu input {
  padding: 15px;
  border-radius: 12px;
  font-size: 18px;
  background-color: var(--card-bg);
  color: var(--text-primary);
  border: 2px solid var(--border-color);
  outline: none;
  width: 100%;
}
#side-menu input:focus {
    border-color: var(--accent-pink);
    box-shadow: 0 0 10px rgba(255, 105, 180, 0.7);
}

.nav-link {
    color: var(--text-primary);
    text-decoration: none;
    padding: 18px 25px; 
    font-size: 20px;
    font-weight: 600;
    transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
    outline: none;
}

/* Foco en Menu Links */
.nav-link:focus {
    background-color: var(--card-bg);
    color: var(--focus-color);
    box-shadow: inset 6px 0 0 var(--focus-color);
    /* Importante para la navegaci√≥n horizontal */
    transform: scale(1.05); 
}

/* --- Main & Screens (Ajuste para dejar espacio al men√∫) --- */
main {
  position: relative;
  /* Margen a la izquierda igual al ancho del men√∫ */
  margin-left: var(--menu-width); 
  padding: 20px 0;
  height: 100vh;
  overflow-y: scroll; /* Permitir scroll solo en el contenido principal */
}

.screen {
  display: none;
  animation: fadeIn 0.3s ease;
  padding-bottom: 50px;
}
.screen.active {
  display: block;
}

/* El resto del CSS se mantiene igual para cards, banner, detalle, etc. */
.loader-container { z-index: 10000; }
.banner { height: 40vh; } /* Reducir altura del banner */
.card:focus {
    transform: scale(var(--focus-scale));
    box-shadow: 0 15px 40px rgba(0,0,0,.8);
    outline: 6px solid var(--focus-color); 
    z-index: 5;
}

/* ... Resto del CSS ... */
</style>
<script src="https://cdn.jsdelivr.net/npm/hls.js@4.0.0/dist/hls.min.js"></script>
</head>
<body>

<div id="loader" class="loader-container">
    <div class="loader"></div>
</div>

<nav id="side-menu" class="permanent-menu">
    <div class="search-container">
        <input id="search" type="text" placeholder="Buscar..." tabindex="0"/> 
    </div>
    <a href="#" class="nav-link" data-screen="home" tabindex="0">üè† Inicio</a>
    <a href="#" class="nav-link" data-screen="favorites" tabindex="0">‚≠ê Favoritos</a>
    <a href="#" class="nav-link" data-screen="watched" tabindex="0">‚úîÔ∏è Vistos</a>
</nav>

<header style="display: none;">
    <div class="logo-container">
        <h1 id="header-title">Kawaii Play TV</h1>
    </div>
</header>

<main id="main-content">
    <div id="banner" class="banner">
      <img id="banner-bg" class="banner-bg" src="" alt="Live channel background">
      <h2 id="banner-title"></h2>
      <a id="btn-live" style="/* ... estilos inline ... */" href="#" target="_blank" rel="noopener noreferrer" tabindex="0">Ver en directo</a>
    </div>
    
    <div id="home" class="screen active" tabindex="0"> 
        </div>
    
    <div id="detail" class="screen" tabindex="0"> 
        </div>
    
    <div id="favorites" class="screen" tabindex="0"></div>
    <div id="watched" class="screen" tabindex="0"></div>
</main>

<script>
// Key Codes para D-Pad de TV
const KEY_CODES = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    ESC: 27
};

// ... (URLs y constantes se mantienen) ...

const mainContent = document.getElementById("main-content");
const navLinks = Array.from(document.querySelectorAll('#side-menu .nav-link'));
const menuElements = [searchInput, ...navLinks]; // Elementos enfocables del men√∫

// State (se mantiene)
let currentFocusedElement = null; 

// ... (Utility functions, data loading, rendering se mantienen) ...
// Nota: Eliminar la l√≥gica de apertura/cierre de men√∫ (hamburgerBtn.addEventListener, menuOverlay.addEventListener)

function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screen = document.getElementById(screenId);
    if(screen) screen.classList.add('active');
    
    const link = document.querySelector(`.nav-link[data-screen="${screenId}"]`);
    document.getElementById('header-title').textContent = link ? link.textContent.trim().substring(2) : (screenId === 'detail' ? 'Detalles' : "Kawaii Play TV");
    document.getElementById('banner').style.display = screenId === 'home' ? 'flex' : 'none';

    // TV Focus Logic: Set initial focus
    setTimeout(() => {
        let initialFocusTarget;
        if (screenId === 'detail') {
            initialFocusTarget = backBtn;
        } else {
             // En Home, Favorites o Watched, el foco inicial es el primer elemento del contenido principal
             initialFocusTarget = screen.querySelector('#btn-live') || screen.querySelector('.card') || menuElements[0]; 
        }
        
        if (initialFocusTarget) {
            initialFocusTarget.focus();
            currentFocusedElement = initialFocusTarget;
            // Asegurar que el contenido principal tenga scroll al tope al cambiar de pantalla
            mainContent.scrollTop = 0; 
        }
    }, 100);
}

// ... (renderHome, createSection, Card Creators, openItem, playVideo se mantienen) ...

// Se corrige el bug del bot√≥n ATR√ÅS
backBtn.addEventListener("click", () => {
    // Deshabilitar elementos interactivos de detalle
    [backBtn, playActionBtn, favBtn].forEach(el => el.setAttribute('tabindex', '-1'));
    document.querySelectorAll('.episode-btn').forEach(el => el.setAttribute('tabindex', '-1'));
    
    const fromScreen = document.querySelector('.screen.from-detail');
    if (fromScreen) {
        switchScreen(fromScreen.id);
        fromScreen.classList.remove('from-detail');
    } else {
        switchScreen('home');
    }
    // Asegurar que el foco vuelva al men√∫ (si no hay contenido) o al banner/primera card
    (document.querySelector('.card') || menuElements[0]).focus();
});

// Los nav-links deben estar habilitados por defecto, pero con la l√≥gica de switchScreen
document.querySelectorAll('.nav-link').forEach(link => {
    link.addEventListener('click', (e) => {
        e.preventDefault();
        const screen = e.target.dataset.screen;
        
        if (screen === 'favorites') renderFavorites();
        if (screen === 'watched') renderWatched();
        
        switchScreen(screen);
        // El foco permanece en el link activo o se mueve al contenido si se presiona RIGHT
    });
    link.addEventListener('keyup', (e) => {
        if (e.keyCode === KEY_CODES.ENTER) link.click();
    });
});

// --- TV FOCUS NAVIGATION (D-Pad) L√ìGICA FINAL Y ARREGLADA ---

document.addEventListener('keydown', (e) => {
    if (e.keyCode === KEY_CODES.ESC) {
        e.preventDefault();
        if (document.getElementById('detail').classList.contains('active')) {
            backBtn.click();
        }
        return;
    }

    if (document.getElementById('detail').classList.contains('active')) {
        // En detalle, s√≥lo navega entre elementos enfocables de arriba a abajo
        handleVerticalFocus(e, '#detail button');
        return;
    }

    // L√≥gica principal de navegaci√≥n TV (Men√∫ vs Contenido)
    if ([KEY_CODES.LEFT, KEY_CODES.UP, KEY_CODES.RIGHT, KEY_CODES.DOWN].includes(e.keyCode)) {
        handleTVFocus(e);
    }
});

function handleTVFocus(e) {
    const currentActive = document.activeElement;
    const isMenuFocused = menuElements.includes(currentActive) || currentActive === searchInput;

    e.preventDefault();

    if (isMenuFocused) {
        handleMenuNavigation(e, currentActive);
    } else {
        // Asume que estamos en el contenido principal (cards, banner, botones)
        handleGridFocus(e, currentActive);
    }
}

/**
 * 1. Navegaci√≥n dentro del men√∫ vertical fijo.
 */
function handleMenuNavigation(e, currentActive) {
    const navElements = menuElements.filter(el => el.getAttribute('tabindex') !== '-1');
    const currentIndex = navElements.indexOf(currentActive);
    let nextElement = null;

    if (e.keyCode === KEY_CODES.UP) {
        // UP: Mover hacia arriba (circular)
        let nextIndex = (currentIndex - 1 + navElements.length) % navElements.length;
        nextElement = navElements[nextIndex];

    } else if (e.keyCode === KEY_CODES.DOWN) {
        // DOWN: Mover hacia abajo (circular)
        let nextIndex = (currentIndex + 1) % navElements.length;
        nextElement = navElements[nextIndex];
        
    } else if (e.keyCode === KEY_CODES.RIGHT) {
        // RIGHT: Saltar al contenido principal
        const initialFocusTarget = document.getElementById('btn-live') || document.querySelector('.card');
        if (initialFocusTarget) {
            nextElement = initialFocusTarget;
        } else {
            // Si no hay contenido, se queda en el men√∫
            nextElement = currentActive; 
        }
    }
    
    if (nextElement) {
        nextElement.focus();
    }
}


/**
 * 2. Navegaci√≥n en el contenido principal (horizontal y vertical).
 */
function handleGridFocus(e, currentActive) {
    const bannerElements = [document.getElementById('btn-live')]; 
    const isBannerFocused = bannerElements.includes(currentActive);
    const focusableCards = Array.from(document.querySelectorAll('.card:not([tabindex="-1"])'));
    const rowElements = Array.from(document.querySelectorAll('.row'));
    let newFocusElement = null;
    let currentCardRect = currentActive.getBoundingClientRect();

    // LEFT: Volver al Men√∫ Fijo
    if (e.keyCode === KEY_CODES.LEFT) {
        // Si estamos en la primera columna (el elemento m√°s a la izquierda del contenido)
        if (isBannerFocused || (focusableCards.includes(currentActive) && currentActive.previousElementSibling === null)) {
            // Ir al elemento del men√∫ que corresponde a la pantalla actual (o el primero)
            const currentScreenId = document.querySelector('.screen.active').id;
            const targetMenuLink = document.querySelector(`.nav-link[data-screen="${currentScreenId}"]`) || menuElements[0];
            newFocusElement = targetMenuLink;
        } else {
            // Navegaci√≥n horizontal normal entre tarjetas
            let row = currentActive.closest('.row');
            if (row) {
                 const rowCards = Array.from(row.querySelectorAll('.card'));
                 const currentIndex = rowCards.indexOf(currentActive);
                 if (currentIndex > 0) {
                     newFocusElement = rowCards[currentIndex - 1];
                 }
            }
        }
    }
    
    // RIGHT: Navegaci√≥n horizontal normal
    if (e.keyCode === KEY_CODES.RIGHT) {
        let row = currentActive.closest('.row');
        if (row) {
             const rowCards = Array.from(row.querySelectorAll('.card'));
             const currentIndex = rowCards.indexOf(currentActive);
             if (currentIndex !== -1 && currentIndex < rowCards.length - 1) {
                 newFocusElement = rowCards[currentIndex + 1];
             }
        }
    }
    
    // UP / DOWN: Navegaci√≥n vertical
    if ([KEY_CODES.UP, KEY_CODES.DOWN].includes(e.keyCode)) {
        
        // 1. Determinar √≠ndice y posici√≥n actual
        let currentRowIndex = -1; // -1: Banner
        if (!isBannerFocused) {
            rowElements.forEach((row, i) => {
                if (Array.from(row.querySelectorAll('.card')).includes(currentActive)) currentRowIndex = i;
            });
        }
        
        let targetRowIndex = currentRowIndex + (e.keyCode === KEY_CODES.DOWN ? 1 : -1);

        // 2. Transici√≥n Banner <-> Primera Fila
        if (targetRowIndex === -1 && e.keyCode === KEY_CODES.UP) { // De Fila 0 al Banner
            newFocusElement = bannerElements[0];
        } else if (targetRowIndex === 0 && e.keyCode === KEY_CODES.DOWN && isBannerFocused) { // Del Banner a Fila 0
            if (rowElements.length > 0) targetRowIndex = 0;
            else newFocusElement = currentActive; 
        }

        // 3. Transici√≥n entre Filas (Row Indices 0+)
        if (targetRowIndex >= 0 && targetRowIndex < rowElements.length) {
            const targetRowCards = Array.from(rowElements[targetRowIndex].querySelectorAll('.card'));
            
            // L√≥gica de alineaci√≥n horizontal (siempre buscar el m√°s cercano en X)
            let bestMatch = null;
            let minDistance = Infinity;

            const currentCardCenter = currentCardRect.left + currentCardRect.width / 2;
            
            for (const card of targetRowCards) {
                const cardRect = card.getBoundingClientRect();
                const cardCenter = cardRect.left + cardRect.width / 2;
                const distance = Math.abs(currentCardCenter - cardCenter);

                if (distance < minDistance) {
                    minDistance = distance;
                    bestMatch = card;
                }
            }
            newFocusElement = bestMatch;
        }
    }
    
    // 4. Aplicar Foco y Scroll
    if (newFocusElement) {
        newFocusElement.focus();
        currentFocusedElement = newFocusElement;
        
        // Scroll vertical del MAIN
        newFocusElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
        
        // Scroll horizontal del ROW (si aplica)
        let row = newFocusElement.closest('.row');
        if(row) {
            // Ajuste simple para mantener el foco visible en el carrusel
            const rect = newFocusElement.getBoundingClientRect();
            const rowRect = row.getBoundingClientRect();
            if (rect.right > rowRect.right) {
                row.scrollLeft += (rect.right - rowRect.right + 30);
            } else if (rect.left < rowRect.left) {
                 row.scrollLeft -= (rowRect.left - rect.left + 30);
            }
        }
    }
}


// --- INITIALIZATION ---
async function init() {
    loader.classList.remove('hidden');
    // Desactivar el tabindex en todos los elementos del men√∫ (search, links) para que s√≥lo sean enfocables por JS/D-Pad
    [searchInput, ...document.querySelectorAll('#side-menu .nav-link')].forEach(el => el.setAttribute('tabindex', '0'));
    // Desactivar elementos de detalle (ya que est√°n ocultos)
    [backBtn, playActionBtn, favBtn].forEach(el => el.setAttribute('tabindex', '-1'));


    await Promise.all([loadData(), loadM3U()]); 
    renderHome();
    loader.classList.add('hidden');
    
    // Foco inicial en el primer elemento del men√∫ (la barra de b√∫squeda)
    searchInput.focus();
    currentFocusedElement = searchInput;
}

init();
</script>
</body>
</html>
