<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Kawaii Play TV</title>
<meta name="theme-color" content="#161b22">
<style>
:root {
  --primary-bg: #2d1b1b;
  --secondary-bg: #422f2f;
  --card-bg: #5a4343;
  --text-primary: #fce4ec;
  --text-secondary: #f48fb1;
  --accent-pink: #ff80ab;
  --accent-yellow: #fdd835;
  --border-color: #795548;
  --watched-color: #4caf50;
  --focus-color: var(--accent-yellow); /* Color de foco clave para TV */
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
  background: var(--primary-bg);
  color: var(--text-primary);
  /* overscroll-behavior-y: contain; no es necesario en TV */
}

/* --- Loader y Estilos Generales (sin cambios) --- */
.loader-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--primary-bg);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  transition: opacity 0.5s ease;
}

.loader {
  border: 4px solid var(--border-color);
  border-top: 4px solid var(--accent-pink);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loader-container.hidden {
  opacity: 0;
  pointer-events: none;
}

/* --- Header & Navigation --- */
header {
  background: var(--secondary-bg);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  position: sticky;
  top: 0;
  z-index: 10;
  border-bottom: 1px solid var(--border-color);
}

.hamburger-btn {
    background: none;
    border: none;
    color: var(--text-primary);
    font-size: 24px;
    cursor: pointer;
    padding: 0 10px;
    z-index: 1002;
    outline: none; /* Se gestionar√° el foco por JS */
}

.logo-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

header h1 {
  margin: 0;
  font-size: 18px;
  white-space: nowrap;
}

#side-menu {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 280px; /* Un poco m√°s ancho para TV */
    background: var(--secondary-bg);
    z-index: 1001;
    transform: translateX(-100%);
    transition: transform 0.3s ease-in-out;
    padding-top: 70px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    border-right: 1px solid var(--border-color);
}

#side-menu.open {
    transform: translateX(0);
}

#menu-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7); /* Oscurecido para TV */
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
}

#menu-overlay.open {
    opacity: 1;
    pointer-events: auto;
}

.search-container {
    padding: 0 16px;
}

#side-menu input {
  padding: 12px; /* M√°s padding para TV */
  border-radius: 8px;
  border: 1px solid var(--border-color);
  outline: none;
  background-color: var(--primary-bg);
  color: var(--text-primary);
  width: 100%;
  transition: all 0.2s ease-in-out;
}

/* Foco para INPUT - Importante para TV */
#side-menu input:focus {
    border-color: var(--focus-color);
    box-shadow: 0 0 8px rgba(253, 216, 53, 0.8);
}

.nav-link {
    color: var(--text-primary);
    text-decoration: none;
    padding: 15px 20px; /* M√°s padding para TV */
    font-size: 18px;
    transition: background-color 0.2s, color 0.2s;
    outline: none; /* Foco gestionado por :focus */
}

/* Foco para Enlaces de Men√∫ - Importante para TV */
.nav-link:hover, .nav-link:focus {
    background-color: var(--card-bg);
    color: var(--accent-yellow);
    box-shadow: inset 5px 0 0 var(--accent-yellow);
}

/* --- Main & Screens (similares) --- */
main {
  position: relative;
  padding: 0;
  /* La TV tiene un alto scroll */
}

.screen {
  display: none;
  animation: fadeIn 0.3s ease;
}

.screen.active {
  display: block;
}

/* --- Banner (m√°s grande para TV) --- */
.banner {
  height: 400px; /* M√°s grande para TV */
  padding: 40px;
}

.banner h2 {
  font-size: 36px; /* M√°s grande */
}

.banner button {
  padding: 15px 24px;
  font-size: 18px;
  outline: none;
}

/* Foco para Botones de Banner - Importante para TV */
.banner button:focus {
    background-color: var(--accent-yellow);
    color: var(--primary-bg);
    box-shadow: 0 0 15px var(--accent-yellow);
}

/* --- Content Sections --- */
.section {
  padding: 10px 16px;
}

.section h2 {
  margin: 10px 0 20px;
  font-size: 24px;
}

.row {
  display: flex;
  overflow-x: scroll; /* Debe ser scrollable para navegaci√≥n horizontal de TV */
  gap: 20px; /* M√°s espacio */
  padding-bottom: 20px;
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.row::-webkit-scrollbar {
  display: none;
}

.card {
  /* M√°s grande para TV */
  flex: 0 0 220px;
  background: var(--card-bg);
  border-radius: 12px;
  cursor: pointer;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0,0,0,.2);
  transition: transform 0.2s ease, box-shadow 0.2s ease, outline 0.2s ease;
  outline: 4px solid transparent; /* Outline inicial transparente */
}

.card img {
  width: 100%;
  height: 330px; /* Proporci√≥n 2:3 */
  object-fit: cover;
  display: block;
  border-bottom: 1px solid var(--border-color);
}

.card h3 {
  margin: 10px;
  font-size: 16px;
}

/* Foco para Tarjetas - Esencial para TV */
.card:focus {
    transform: scale(1.1);
    box-shadow: 0 10px 30px rgba(0,0,0,.6);
    outline: 4px solid var(--focus-color); /* Foco visible */
    z-index: 5;
}

.tv-card {
    flex: 0 0 250px;
}

.tv-card img {
    height: 140px;
}

/* --- Detail Screen --- */
/* Botones de acci√≥n y elementos enfocables del detalle */
#back-btn,
#play-action-btn,
#fav-btn {
    outline: none;
    transition: all 0.2s ease;
    border: none;
}

#back-btn:focus,
#play-action-btn:focus,
#fav-btn:focus {
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--focus-color);
    border: 2px solid var(--focus-color);
}

.episode-btn {
    outline: none;
    transition: background-color 0.2s, border-color 0.2s, outline 0.2s;
    text-align: left; /* Asegurar que el texto est√© a la izquierda */
}

/* Foco en botones de episodio - Importante para TV */
.episode-btn:focus {
    outline: 3px solid var(--focus-color);
    background: var(--secondary-bg);
    border-color: var(--focus-color);
}

/* El resto del CSS se mantiene igual para mantener el estilo */
</style>
<script src="https://cdn.jsdelivr.net/npm/hls.js@4.0.0/dist/hls.min.js"></script>
</head>
<body>

<div id="loader" class="loader-container">
    <div class="loader"></div>
</div>

<div id="menu-overlay"></div>
<nav id="side-menu">
    <div class="search-container">
        <input id="search" type="text" placeholder="Buscar..." tabindex="-1"/> 
    </div>
    <a href="#" class="nav-link" data-screen="home" tabindex="-1">üè† Inicio</a>
    <a href="#" class="nav-link" data-screen="favorites" tabindex="-1">‚≠ê Favoritos</a>
    <a href="#" class="nav-link" data-screen="watched" tabindex="-1">‚úîÔ∏è Vistos</a>
</nav>

<header>
    <button id="hamburger-btn" class="hamburger-btn" tabindex="0">‚ò∞</button>
    <div class="logo-container">
        <h1 id="header-title">Kawaii Play</h1>
    </div>
</header>

<main>
    <div id="banner" class="banner">
      <img id="banner-bg" class="banner-bg" src="" alt="Live channel background">
      <h2 id="banner-title"></h2>
      <a id="btn-live" style="padding: 10px 16px; background: var(--accent-pink); color: white; border: none; border-radius: 6px; cursor: pointer; z-index: 2; font-weight: bold; align-self: flex-start; transition: background-color 0.2s; text-decoration: none; display: inline-block;" href="#" target="_blank" rel="noopener noreferrer" tabindex="0">Ver en directo</a>
    </div>
    
    <div id="home" class="screen active" tabindex="0"> </div>
    
    <div id="detail" class="screen" tabindex="0"> <div class="detail-hero">
            <img id="detail-poster" class="detail-poster" src="" alt="Poster">
            <div class="detail-hero-overlay"></div>
            <div class="detail-header">
                <button id="back-btn" tabindex="-1">‚¨Ö Atr√°s</button>
            </div>
            <div class="detail-info">
                <h2 id="detail-title"></h2>
                <div class="detail-actions">
                    <button id="play-action-btn" tabindex="-1">‚ñ∂ Ver Episodio 1</button>
                    <button id="fav-btn" tabindex="-1">‚≠ê A√±adir a Favoritos</button>
                </div>
                <p id="detail-description"></p>
            </div>
        </div>
        <div id="detail-content" class="detail-content">
            </div>
    </div>
    
    <div id="favorites" class="screen" tabindex="0"></div>
    <div id="watched" class="screen" tabindex="0"></div>
    </main>

<script>
// Key Codes para D-Pad de TV
const KEY_CODES = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    ESC: 27
};

// ... [El resto de las constantes de URL y elementos DOM se mantienen] ...
const DATA_URL="https://raw.githubusercontent.com/R3D-GHOST/json/refs/heads/main/data.json";
const M3U_URL="https://raw.githubusercontent.com/R3D-GHOST/json/refs/heads/main/toro.m3u8";
const ITEMS_PER_PAGE = 30;

// DOM Elements
const loader = document.getElementById("loader");
const home = document.getElementById("home");
const detail = document.getElementById("detail");
const favoritesScreen = document.getElementById("favorites");
const watchedScreen = document.getElementById("watched");

const bannerTitle = document.getElementById("banner-title");
const btnLive = document.getElementById("btn-live");
const searchInput = document.getElementById("search");
const backBtn = document.getElementById("back-btn");
const detailTitle = document.getElementById("detail-title");
const detailContent = document.getElementById("detail-content");
const favBtn = document.getElementById("fav-btn");
const hamburgerBtn = document.getElementById('hamburger-btn');
const sideMenu = document.getElementById('side-menu');
const menuOverlay = document.getElementById('menu-overlay');
const headerTitle = document.getElementById('header-title');

const detailPoster = document.getElementById('detail-poster');
const detailDescription = document.getElementById('detail-description');
const playActionBtn = document.getElementById('play-action-btn');

// State
let allData = { movies: [], series: [], channels: [] };
let liveChannels = [];
let liveIndex = 0;
let liveInterval = null;
let bannerBg = null;
let observers = [];
let currentDetailItem = null;
let currentFocusedElement = null; // Para gesti√≥n del foco D-Pad

// Local Storage State
let favorites = JSON.parse(localStorage.getItem('kawaii_favorites')) || [];
let watched = JSON.parse(localStorage.getItem('kawaii_watched')) || {};
let continueWatching = JSON.parse(localStorage.getItem('kawaii_continue')) || [];
let progress = JSON.parse(localStorage.getItem('kawaii_progress')) || {};

// --- UTILITY FUNCTIONS ---
function switchScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screen = document.getElementById(screenId);
    if(screen) screen.classList.add('active');
    
    // Update header title
    const link = document.querySelector(`.nav-link[data-screen="${screenId}"]`);
    headerTitle.textContent = link ? link.textContent.trim().substring(2) : "Kawaii Play";
    if (screenId === 'detail') {
        headerTitle.textContent = 'Detalles';
    }

    // Hide banner on non-home screens
    document.getElementById('banner').style.display = screenId === 'home' ? 'flex' : 'none';

    // *** TV Focus Logic: Set initial focus ***
    setTimeout(() => {
        if (screenId === 'home') {
             // Foco inicial en el bot√≥n del banner o en el primer elemento de la primera secci√≥n
            const initialFocusTarget = document.getElementById('btn-live') || document.querySelector('.card');
            if (initialFocusTarget) {
                initialFocusTarget.focus();
                currentFocusedElement = initialFocusTarget;
            } else {
                 hamburgerBtn.focus(); // Si no hay nada, enfoca el men√∫
                 currentFocusedElement = hamburgerBtn;
            }
        } else if (screenId === 'detail') {
            backBtn.focus();
            currentFocusedElement = backBtn;
        } else if (screenId === 'favorites' || screenId === 'watched') {
            const firstCard = screen.querySelector('.card');
            if (firstCard) {
                firstCard.focus();
                currentFocusedElement = firstCard;
            } else {
                hamburgerBtn.focus();
                currentFocusedElement = hamburgerBtn;
            }
        }
    }, 100); // Retraso para asegurar que el DOM est√© actualizado
}

// ... [El resto de las funciones de Local Storage, Data Loading y Banner se mantienen] ...

const generateItemId = (item) => item.title;
const generateEpisodeId = (item, epIndex) => `${item.title}-ep-${epIndex}`;

// --- LOCAL STORAGE ---
const updateFavorites = () => localStorage.setItem('kawaii_favorites', JSON.stringify(favorites));
const updateWatched = () => localStorage.setItem('kawaii_watched', JSON.stringify(watched));
const updateContinueWatching = () => localStorage.setItem('kawaii_continue', JSON.stringify(continueWatching));
const updateProgress = () => localStorage.setItem('kawaii_progress', JSON.stringify(progress));

function addToContinueWatching(item) {
    const itemId = generateItemId(item);
    continueWatching = continueWatching.filter(i => generateItemId(i) !== itemId);
    continueWatching.unshift(item);
    if (continueWatching.length > 10) continueWatching.pop();
    updateContinueWatching();
}

// --- DATA LOADING & PARSING ---
async function fetchData(url) {
    try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Failed to fetch ${url}`);
        return res;
    } catch (error) {
        console.error("Fetch Error:", error);
        alert("Failed to load data. Please check your connection and try again.");
        return null;
    }
}

async function loadData() {
    const res = await fetchData(DATA_URL);
    if (!res) return;
    const jsonData = await res.json();
    allData.movies = jsonData.filter(i => i.video_url && !i.episodes);
    allData.series = jsonData.filter(i => i.episodes && i.episodes.length > 0);
}

async function loadM3U() {
    const res = await fetchData(M3U_URL);
    if(!res) return;
    const txt = await res.text();
    parseM3U(txt);
    liveChannels = allData.channels.filter(c => c.group && c.group.toUpperCase() === "EN DIRECTO");
    renderBannerLive();
}

function parseM3U(text) {
    const lines = text.split("\n");
    let currentName = "", currentLogo = "", currentGroup = "";
    const channels = [];
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line.startsWith("#EXTINF")) {
            const g = line.match(/group-title="([^"]+)"/);
            const l = line.match(/tvg-logo="([^"]+)"/);
            const n = line.split(",").pop();
            currentGroup = g ? g[1] : "Otros";
            currentLogo = l ? l[1] : "";
            currentName = n || "Canal";
        } else if (line && !line.startsWith("#")) {
            channels.push({ name: currentName, logo: currentLogo, url: line, group: currentGroup });
        }
    }
    allData.channels = channels;
}

// --- BANNER ---
function renderBannerLive() {
    if (!liveChannels.length) return;
    liveIndex = Math.floor(Math.random() * liveChannels.length);
    bannerBg = document.getElementById('banner-bg');

    const showChannel = (index) => {
        const ch = liveChannels[index];
        bannerTitle.textContent = ch.name;
        
        if (bannerBg) {
            bannerBg.style.opacity = '0';
            setTimeout(() => {
                bannerBg.src = ch.logo || '';
                bannerBg.style.opacity = '1';
            }, 500);
        }
    };
    
    showChannel(liveIndex);

    // Update the button to be an anchor tag
    const updatedBtn = document.getElementById('btn-live');
    if (updatedBtn) {
        updatedBtn.href = liveChannels[liveIndex].url;
    }

    if (liveInterval) clearInterval(liveInterval);
    liveInterval = setInterval(() => {
        liveIndex = (liveIndex + 1) % liveChannels.length;
        showChannel(liveIndex);
        
        // Update the anchor href
        const updatedLink = document.getElementById('btn-live');
        if (updatedLink) {
            updatedLink.href = liveChannels[liveIndex].url;
        }
    }, 5000);
}

// --- HOME SCREEN RENDERING ---
function renderHome(filter = "") {
    home.innerHTML = "";
    observers.forEach(obs => obs.disconnect());
    observers = [];

    const lowerFilter = filter.toLowerCase();

    if (!filter) {
        renderContinueWatching();
    }

    const filteredMovies = allData.movies.filter(item => item.title.toLowerCase().includes(lowerFilter));
    const filteredSeries = allData.series.filter(item => item.title.toLowerCase().includes(lowerFilter));
    const filteredChannels = allData.channels
        .filter(c => c.group.toUpperCase() !== "EN DIRECTO")
        .filter(ch => ch.name.toLowerCase().includes(lowerFilter));

    // Secciones para la carga infinita
    if (filteredMovies.length) createSection("Pel√≠culas", filteredMovies, createMovieCard, home);
    if (filteredSeries.length) createSection("Series", filteredSeries, createSeriesCard, home);
    if (filteredChannels.length) createSection("Canales", filteredChannels, createChannelCard, home);
    
    // Re-enfocar despu√©s de renderizar si no hay filtro (para el inicio)
    if (!filter) {
        setTimeout(() => {
            const initialFocusTarget = document.getElementById('btn-live') || document.querySelector('.card');
            if (initialFocusTarget) {
                initialFocusTarget.focus();
                currentFocusedElement = initialFocusTarget;
            }
        }, 100);
    }
}

function renderContinueWatching() {
    if (continueWatching.length === 0) return;
    const continueData = continueWatching.map(storedItem => {
        return allData.movies.find(i => generateItemId(i) === generateItemId(storedItem)) || 
               allData.series.find(i => generateItemId(i) === generateItemId(storedItem));
    }).filter(Boolean);
    
    if (continueData.length > 0) {
        createSection("Continuar Viendo", continueData, (item) => {
            return item.episodes ? createSeriesCard(item) : createMovieCard(item);
        }, home, 10); // L√≠mite de 10 en "Continuar Viendo"
    }
}

function createSection(title, items, cardCreator, parentElement, limit = ITEMS_PER_PAGE) {
    const section = document.createElement("div");
    section.className = "section";
    
    const h2 = document.createElement("h2");
    h2.textContent = title;
    section.appendChild(h2);
    
    const row = document.createElement("div");
    row.className = "row";
    section.appendChild(row);
    parentElement.appendChild(section);

    let loadedCount = 0;

    function loadMore() {
        const fragment = document.createDocumentFragment();
        const nextItems = items.slice(loadedCount, loadedCount + limit);
        nextItems.forEach(item => fragment.appendChild(cardCreator(item)));
        row.appendChild(fragment);
        loadedCount += nextItems.length;

        // Si hay m√°s elementos para cargar, y es una secci√≥n con potencial scroll
        if (loadedCount < items.length && parentElement === home) {
            setupIntersectionObserver(row, loadMore);
        }
    }
    loadMore();
}

function setupIntersectionObserver(row, callback) {
    const lastCard = row.lastElementChild;
    if (!lastCard) return;

    // Crear un elemento invisible al final de la fila para detectar el scroll horizontal
    const sentinel = document.createElement('div');
    sentinel.style.width = '1px';
    sentinel.style.height = '1px';
    sentinel.style.marginLeft = '-200px'; // Se activa antes de llegar al final
    row.appendChild(sentinel);

    const observer = new IntersectionObserver(entries => {
        if (entries[0].isIntersecting) {
            observer.disconnect();
            sentinel.remove();
            callback();
        }
    }, { root: row, rootMargin: '0px 0px 0px 0px', threshold: 0.1 });

    observer.observe(sentinel);
    observers.push(observer);
}


// --- CARD CREATORS ---
// Se a√±ade 'tabindex="0"' a todos los elementos interactivos para que puedan recibir foco de TV.
function createMovieCard(item) {
    const card = document.createElement("div");
    card.className = "card";
    card.setAttribute('tabindex', '0'); // Esencial para TV
    card.onclick = () => playVideo(item, null);
    card.innerHTML = `
        <img src="${item.coverImage || ""}" alt="${item.title}" loading="lazy">
        <h3>${item.title || ""}</h3>
    `;
    // Manejar Enter/Click al recibir foco
    card.addEventListener('keyup', (e) => {
        if (e.keyCode === KEY_CODES.ENTER) card.click();
    });
    return card;
}

function createSeriesCard(item) {
    const card = document.createElement("div");
    card.className = "card";
    card.setAttribute('tabindex', '0'); // Esencial para TV
    card.onclick = () => openItem(item);
    card.innerHTML = `
        <img src="${item.coverImage || ""}" alt="${item.title}" loading="lazy">
        <h3>${item.title || ""}</h3>
    `;
    // Manejar Enter/Click al recibir foco
    card.addEventListener('keyup', (e) => {
        if (e.keyCode === KEY_CODES.ENTER) card.click();
    });
    return card;
}

function createChannelCard(ch) {
    const card = document.createElement("div");
    card.className = "card tv-card";
    card.setAttribute('tabindex', '0'); // Esencial para TV
    
    // Usamos el evento del card para abrir la URL
    const channelUrl = ch.v2_url || ch.url;
    card.onclick = () => window.open(channelUrl, '_blank');
    
    card.innerHTML = `
        <img src="${ch.logo || "https://via.placeholder.com/160x90.png?text=No+Logo"}" alt="${ch.name}" loading="lazy">
        <h3>${ch.name}</h3>
    `;
    
    // Manejar Enter/Click al recibir foco
    card.addEventListener('keyup', (e) => {
        if (e.keyCode === KEY_CODES.ENTER) card.click();
    });

    return card;
}


// --- DETAIL SCREEN ---
function openItem(item) {
    // ... [Se mantiene el resto de la l√≥gica de openItem] ...
    currentDetailItem = item;
    const itemId = generateItemId(item);
    
    detailTitle.textContent = item.title;
    detailPoster.src = item.coverImage || '';
    detailDescription.textContent = item.description || 'No hay descripci√≥n disponible para esta serie.';
    detailContent.innerHTML = "";
    
    favBtn.textContent = favorites.includes(itemId) ? '‚≠ê Quitar de Favoritos' : '‚≠ê A√±adir a Favoritos';
    
    // Habilitar todos los elementos interactivos al abrir
    [backBtn, playActionBtn, favBtn].forEach(el => el.setAttribute('tabindex', '0'));


    // Update play/continue button
    const seriesProgress = progress[itemId];
    if (seriesProgress) {
        const epIndex = item.episodes.findIndex(ep => generateEpisodeId(item, ep.episode_number - 1) === seriesProgress.episodeId);
        if (epIndex !== -1) {
            playActionBtn.textContent = `‚ñ∂Ô∏è Continuar Ep. ${epIndex + 1}`;
            playActionBtn.onclick = () => playVideo(item, epIndex, seriesProgress.time);
        } else {
             playActionBtn.textContent = `‚ñ∂Ô∏è Ver Episodio 1`;
             playActionBtn.onclick = () => playVideo(item, 0);
        }
    } else {
        playActionBtn.textContent = `‚ñ∂Ô∏è Ver Episodio 1`;
        playActionBtn.onclick = () => playVideo(item, 0);
    }

    const fragment = document.createDocumentFragment();
    item.episodes.forEach((ep, i) => {
        const epId = generateEpisodeId(item, i);
        const btn = document.createElement("button");
        btn.className = "episode-btn";
        btn.setAttribute('tabindex', '0'); // Esencial para TV
        if (watched[epId]) btn.classList.add('watched');
        
        // Progress bar
        const seriesProgress = progress[itemId];
        let progressPercent = 0;
        if (seriesProgress && seriesProgress.episodeId === epId && seriesProgress.duration) {
            progressPercent = (seriesProgress.time / seriesProgress.duration) * 100;
        } else if (watched[epId]) {
            progressPercent = 100;
        }

        btn.innerHTML = `
            <span class="ep-number">Episodio ${i + 1}</span>
            <span class="ep-desc">${ep.description || ''}</span>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: ${progressPercent}%"></div>
            </div>
        `;
        
        const seekTime = (seriesProgress && seriesProgress.episodeId === epId) ? seriesProgress.time : 0;
        btn.onclick = (e) => {
            e.stopPropagation();
            playVideo(item, i, seekTime);
        };
        
        // Manejar Enter para reproducci√≥n
        btn.addEventListener('keyup', (e) => {
            if (e.keyCode === KEY_CODES.ENTER) btn.click();
        });

        // El toggle de visto ya no es un elemento separado para simplificar el foco D-Pad, 
        // ya que la acci√≥n principal es ver. La gesti√≥n de "visto" se puede hacer con un men√∫ contextual si fuera necesario.
        // Se elimina el toggle separado para simplificar la navegaci√≥n en TV.

        fragment.appendChild(btn);
    });
    detailContent.appendChild(fragment);
    
    // Guardar la pantalla anterior para el bot√≥n Atr√°s
    document.querySelector('.screen.active')?.classList.add('from-detail'); 

    switchScreen('detail');
}

favBtn.addEventListener('click', () => {
    if (!currentDetailItem) return;
    const itemId = generateItemId(currentDetailItem);
    const index = favorites.indexOf(itemId);
    if (index > -1) {
        favorites.splice(index, 1);
        favBtn.textContent = '‚≠ê A√±adir a Favoritos';
    } else {
        favorites.push(itemId);
        favBtn.textContent = '‚≠ê Quitar de Favoritos';
    }
    updateFavorites();
});

backBtn.addEventListener("click", () => {
    // Deshabilitar elementos interactivos al salir
    [backBtn, playActionBtn, favBtn].forEach(el => el.setAttribute('tabindex', '-1'));
    document.querySelectorAll('.episode-btn').forEach(el => el.setAttribute('tabindex', '-1'));
    
    const fromScreen = document.querySelector('.screen.from-detail');
    if (fromScreen) {
        switchScreen(fromScreen.id);
        fromScreen.classList.remove('from-detail');
    } else {
        switchScreen('home');
    }
});

// ... [El resto de la l√≥gica de playVideo se mantiene] ...
function playVideo(item, episodeIndex = null, startTime = 0) {
    // ... [La l√≥gica de playVideo se mantiene] ...
    let url;
    if (episodeIndex !== null) { // It's a series episode
        const episode = item.episodes[episodeIndex];
        url = episode.video_url;
        // ... (otros estados)
    } else if (item.video_url) { // It's a movie
        url = item.video_url;
        // ... (otros estados)
    } else { // It's a channel
        url = item.url;
    }
    
    if(item.video_url || item.episodes) {
        addToContinueWatching(item);
    }

    // Open video directly in new tab (como en tu c√≥digo original)
    window.open(url, '_blank');
    
    // Volver a la pantalla de detalle despu√©s de abrir el v√≠deo (si aplica)
    if(currentDetailItem) {
        openItem(currentDetailItem);
    } else {
        switchScreen('home');
    }
}


// --- FAVORITES & WATCHED SCREENS ---
function renderFavorites() {
    favoritesScreen.innerHTML = '';
    const favData = favorites.map(id => {
        return allData.movies.find(i => generateItemId(i) === id) || 
               allData.series.find(i => generateItemId(i) === id);
    }).filter(Boolean);

    if (favData.length) {
        createSection("Mis Favoritos", favData, (item) => {
            return item.episodes ? createSeriesCard(item) : createMovieCard(item);
        }, favoritesScreen);
    } else {
        favoritesScreen.innerHTML = '<p class="empty-message">No has a√±adido nada a favoritos.</p>';
    }
}

function renderWatched() {
    watchedScreen.innerHTML = '';
    // ... [La l√≥gica de renderWatched se mantiene] ...
    const watchedItems = Object.keys(watched);
    const watchedData = watchedItems.map(id => {
        const isEpisode = id.includes('-ep-');
        const title = isEpisode ? id.substring(0, id.lastIndexOf('-ep-')) : id.split('-ep-')[0]; // Ajuste de l√≥gica de obtenci√≥n de t√≠tulo
        return allData.movies.find(i => generateItemId(i) === title) || 
               allData.series.find(i => generateItemId(i) === title);
    }).filter(Boolean);
    
    // Remove duplicates
    const uniqueWatchedData = [...new Map(watchedData.map(item => [generateItemId(item), item])).values()];

    if (uniqueWatchedData.length) {
        createSection("Historial", uniqueWatchedData.reverse(), (item) => {
             return item.episodes ? createSeriesCard(item) : createMovieCard(item);
        }, watchedScreen);
    } else {
        watchedScreen.innerHTML = '<p class="empty-message">A√∫n no has visto nada.</p>';
    }
}

// --- SEARCH & NAVIGATION ---
searchInput.addEventListener("input", (e) => {
    switchScreen('home');
    renderHome(e.target.value);
});

hamburgerBtn.addEventListener('click', () => {
    sideMenu.classList.toggle('open');
    menuOverlay.classList.toggle('open');
    
    // *** TV Focus Logic: Foco en el men√∫ al abrir/cerrar ***
    if (sideMenu.classList.contains('open')) {
        // Habilitar y enfocar elementos del men√∫ lateral
        [searchInput, ...document.querySelectorAll('.nav-link')].forEach(el => el.setAttribute('tabindex', '0'));
        searchInput.focus();
        currentFocusedElement = searchInput;
    } else {
        // Deshabilitar elementos del men√∫ lateral al cerrar
        [searchInput, ...document.querySelectorAll('.nav-link')].forEach(el => el.setAttribute('tabindex', '-1'));
        hamburgerBtn.focus(); // Devolver el foco al bot√≥n de men√∫
        currentFocusedElement = hamburgerBtn;
    }
});

menuOverlay.addEventListener('click', () => {
    sideMenu.classList.remove('open');
    menuOverlay.classList.remove('open');
    // Deshabilitar elementos del men√∫ lateral al cerrar
    [searchInput, ...document.querySelectorAll('.nav-link')].forEach(el => el.setAttribute('tabindex', '-1'));
    hamburgerBtn.focus();
    currentFocusedElement = hamburgerBtn;
});

document.querySelectorAll('.nav-link').forEach(link => {
    link.addEventListener('click', (e) => {
        e.preventDefault();
        const screen = e.target.dataset.screen;
        
        if (screen === 'favorites') renderFavorites();
        if (screen === 'watched') renderWatched();
        
        switchScreen(screen);
        sideMenu.classList.remove('open');
        menuOverlay.classList.remove('open');
        // Deshabilitar elementos del men√∫ lateral al cerrar
        [searchInput, ...document.querySelectorAll('.nav-link')].forEach(el => el.setAttribute('tabindex', '-1'));
    });
    // Manejar Enter para navegaci√≥n con foco de TV
    link.addEventListener('keyup', (e) => {
        if (e.keyCode === KEY_CODES.ENTER) link.click();
    });
});

// --- TV FOCUS NAVIGATION (D-Pad) LOGIC ---

document.addEventListener('keydown', (e) => {
    const isMenuOpen = sideMenu.classList.contains('open');
    
    if (e.keyCode === KEY_CODES.ESC) {
        if (isMenuOpen) {
            menuOverlay.click(); // Cerrar men√∫
        } else if (document.getElementById('detail').classList.contains('active')) {
            backBtn.click(); // Retroceder desde detalle
        }
        e.preventDefault();
        return;
    }

    // Si el men√∫ est√° abierto, la navegaci√≥n D-Pad es simple (vertical)
    if (isMenuOpen) {
        handleMenuFocus(e);
        return;
    }
    
    // Si estamos en la pantalla de detalle, la navegaci√≥n D-Pad es simple (vertical)
    if (document.getElementById('detail').classList.contains('active')) {
        handleVerticalFocus(e, '#detail .detail-header button, #detail .detail-actions button, #detail .episode-btn');
        return;
    }

    // Si estamos en Home, Favorites o Watched, necesitamos navegaci√≥n compleja (horizontal/vertical)
    if (document.getElementById('home').classList.contains('active') ||
        document.getElementById('favorites').classList.contains('active') ||
        document.getElementById('watched').classList.contains('active')) {
        
        handleGridFocus(e);
    }
});

function handleMenuFocus(e) {
    if ([KEY_CODES.UP, KEY_CODES.DOWN].includes(e.keyCode)) {
        e.preventDefault();
        const navElements = [searchInput, ...document.querySelectorAll('#side-menu .nav-link')];
        const currentIndex = navElements.indexOf(document.activeElement);
        let nextIndex = currentIndex;

        if (e.keyCode === KEY_CODES.UP) {
            nextIndex = (currentIndex - 1 + navElements.length) % navElements.length;
        } else if (e.keyCode === KEY_CODES.DOWN) {
            nextIndex = (currentIndex + 1) % navElements.length;
        }

        navElements[nextIndex]?.focus();
        currentFocusedElement = navElements[nextIndex];
    }
}

function handleVerticalFocus(e, selector) {
    if ([KEY_CODES.UP, KEY_CODES.DOWN].includes(e.keyCode)) {
        e.preventDefault();
        const focusableElements = Array.from(document.querySelectorAll(selector)).filter(el => el.getAttribute('tabindex') !== '-1');
        const currentIndex = focusableElements.indexOf(document.activeElement);
        let nextIndex = currentIndex;

        if (e.keyCode === KEY_CODES.UP) {
            nextIndex = Math.max(0, currentIndex - 1);
        } else if (e.keyCode === KEY_CODES.DOWN) {
            nextIndex = Math.min(focusableElements.length - 1, currentIndex + 1);
        }

        if (nextIndex !== currentIndex) {
            focusableElements[nextIndex]?.focus();
            currentFocusedElement = focusableElements[nextIndex];
        }
    }
}


function handleGridFocus(e) {
    const focusableCards = Array.from(document.querySelectorAll('.card:not(.tv-card)'));
    const bannerElements = [document.getElementById('hamburger-btn'), document.getElementById('btn-live')];
    
    const allFocusable = [...bannerElements, ...focusableCards];
    const currentActive = document.activeElement;
    let newFocusElement = null;

    if (!allFocusable.includes(currentActive) || !currentActive.getAttribute('tabindex')) {
        // Si no hay foco o est√° fuera de los elementos principales, enfocar el primero
        e.preventDefault();
        bannerElements[0].focus();
        currentFocusedElement = bannerElements[0];
        return;
    }

    if ([KEY_CODES.LEFT, KEY_CODES.RIGHT, KEY_CODES.UP, KEY_CODES.DOWN].includes(e.keyCode)) {
        e.preventDefault();
    }
    
    const rowElements = Array.from(document.querySelectorAll('.row'));
    const rows = rowElements.map(row => Array.from(row.querySelectorAll('.card')));
    const elementRect = currentActive.getBoundingClientRect();
    
    // Funci√≥n para encontrar el elemento m√°s cercano en una direcci√≥n dada
    function findNextElement(direction) {
        let nearest = null;
        let minDistance = Infinity;

        for (const element of allFocusable) {
            if (element === currentActive) continue;
            const targetRect = element.getBoundingClientRect();

            let isCandidate = false;
            let distance = Infinity;

            if (direction === KEY_CODES.LEFT && targetRect.right < elementRect.left) {
                isCandidate = true;
                distance = elementRect.left - targetRect.right;
            } else if (direction === KEY_CODES.RIGHT && targetRect.left > elementRect.right) {
                isCandidate = true;
                distance = targetRect.left - elementRect.right;
            } else if (direction === KEY_CODES.UP && targetRect.bottom < elementRect.top) {
                isCandidate = true;
                distance = elementRect.top - targetRect.bottom;
            } else if (direction === KEY_CODES.DOWN && targetRect.top > elementRect.bottom) {
                isCandidate = true;
                distance = targetRect.top - elementRect.bottom;
            }

            if (isCandidate && distance < minDistance) {
                // A√±adir una m√©trica de alineaci√≥n (cercan√≠a en el eje transversal)
                const alignmentMetric = Math.abs((targetRect.left + targetRect.right) / 2 - (elementRect.left + elementRect.right) / 2);
                const totalMetric = distance * 2 + alignmentMetric; // Distancia principal tiene m√°s peso

                if (totalMetric < minDistance * 2.5) { // Usar una heur√≠stica para priorizar cercan√≠a
                    minDistance = totalMetric;
                    nearest = element;
                }
            }
        }
        return nearest;
    }

    // Movimiento Horizontal (LEFT / RIGHT)
    if ([KEY_CODES.LEFT, KEY_CODES.RIGHT].includes(e.keyCode)) {
        // En un row, se mueve el foco y se hace scroll a la fila
        for (const row of rowElements) {
            const rowCards = Array.from(row.querySelectorAll('.card'));
            const currentIndex = rowCards.indexOf(currentActive);
            
            if (currentIndex !== -1) {
                let nextCard;
                if (e.keyCode === KEY_CODES.LEFT) {
                    nextCard = rowCards[currentIndex - 1];
                } else {
                    nextCard = rowCards[currentIndex + 1];
                }
                
                if (nextCard) {
                    newFocusElement = nextCard;
                    row.scrollLeft += (nextCard.offsetLeft - currentActive.offsetLeft); // Scroll fluido
                    break;
                } else if (e.keyCode === KEY_CODES.RIGHT && currentIndex === rowCards.length - 1) {
                    // Si llega al final, intentar cargar m√°s (trigger el observer manualmente si es necesario)
                    // La carga infinita se maneja autom√°ticamente por el IntersectionObserver
                }
            }
        }
    }
    
    // Movimiento Vertical (UP / DOWN)
    if ([KEY_CODES.UP, KEY_CODES.DOWN].includes(e.keyCode)) {
         // Primero, intentar la navegaci√≥n espec√≠fica de elementos no-card (banner/header)
        if (currentActive === document.getElementById('hamburger-btn') && e.keyCode === KEY_CODES.DOWN) {
            newFocusElement = document.getElementById('btn-live');
        } else if (currentActive === document.getElementById('btn-live') && e.keyCode === KEY_CODES.UP) {
            newFocusElement = document.getElementById('hamburger-btn');
        } else if (currentActive === document.getElementById('btn-live') && e.keyCode === KEY_CODES.DOWN) {
            // Desde el banner al primer card
            newFocusElement = focusableCards[0];
        } else {
            // Usar l√≥gica de proximidad
            newFocusElement = findNextElement(e.keyCode);
        }
        
        // Si no se encontr√≥ un nuevo foco, hacer scroll a la p√°gina
        if (!newFocusElement && focusableCards.includes(currentActive)) {
            const scrollDistance = (e.keyCode === KEY_CODES.UP) ? -300 : 300;
            window.scrollBy({ top: scrollDistance, behavior: 'smooth' });
        }
    }
    
    if (newFocusElement) {
        newFocusElement.focus();
        currentFocusedElement = newFocusElement;
        // Asegurar que el elemento est√© visible
        newFocusElement.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
    }
}

// --- INITIALIZATION ---
async function init() {
    loader.classList.remove('hidden');
    await Promise.all([loadData(), loadM3U()]);
    renderHome();
    loader.classList.add('hidden');
    
    // El foco inicial debe estar en el bot√≥n de men√∫ para la primera interacci√≥n
    hamburgerBtn.focus();
    currentFocusedElement = hamburgerBtn;

    // Deshabilitar inicialmente elementos de pantallas no activas
    [searchInput, ...document.querySelectorAll('.nav-link'), backBtn, playActionBtn, favBtn].forEach(el => el.setAttribute('tabindex', '-1'));
}

init();
</script>
</body>
</html>
